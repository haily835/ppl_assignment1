Given the AST declarations as follows:

class Program: #decl:List[VarDecl],exp:Exp

class VarDecl: #name:str,typ:Type

class Type(ABC): #abstract class

class IntType(Type)

class FloatType(Type)

class BoolType(Type)

class Exp(ABC): #abstract class

class BinOp(Exp): #op:str,e1:Exp,e2:Exp #op is +,-,*,/,&&,||, >, <, ==, or  !=

class UnOp(Exp): #op:str,e:Exp #op is -, !

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

class Id(Exp): #name:str

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):pass

    def visitVarDecl(self,ctx:VarDecl,o): pass

    def visitIntType(self,ctx:IntType,o):pass

    def visitFloatType(self,ctx:FloatType,o):pass

    def visitBoolType(self,ctx:BoolType,o):pass

    def visitBinOp(self,ctx:BinOp,o): pass

    def visitUnOp(self,ctx:UnOp,o):pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

    def visitId(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to check the following type constraints:

+ , - and * accept their operands in int or float type and return float type if at least one of their operands is in float type, otherwise, return int type
/ accepts their operands in int or float type and returns float type
!, && and || accept their operands in bool type and return bool type
>, <, == and != accept their operands in any type but must in the same type and return bool type
the type of an Id is from the declarations, if the Id is not in the declarations, exception UndeclaredIdentifier should be raised with the name of the Id. 
If the expression does not conform the type constraints, the StaticCheck will raise exception TypeMismatchInExpression with the innermost sub-expression that contains type mismatch.
Your code starts at line 90

class StaticCheck(Visitor):
    def visitProgram(self,ctx:Program,o):
        o = [x.accept(self,None) for x in ctx.decl]
        ctx.exp.accept(self,o)
    
    def visitVarDecl(self,ctx:VarDecl,o):
        return (ctx.name, ctx.typ.accept(self, None))

    def visitIntType(self,ctx:IntType,o):
        return "int"

    def visitFloatType(self,ctx:FloatType,o):
        return "int"
    
    def visitBoolType(self,ctx:BoolType,o):
        return "bool"

    def visitBinOp(self,ctx:BinOp,o):
        if ctx.op == "+" or ctx.op == "-" or ctx.op == "*" or ctx.op == "/":
            if ctx.e1.accept(self, o) == "bool" or ctx.e2.accept(self, o) == "bool":
                raise TypeMismatchInExpression(ctx)
            elif ctx.e1.accept(self, o) == "float" or ctx.e2.accept(self, o) == "float" or ctx.op == "/":
                return "float"
            else:
                return "int"
        elif ctx.op == "&&" or ctx.op == "||":
            if ctx.e1.accept(self, o) == "bool" and ctx.e2.accept(self, o) == "bool":
                return "bool"
            else:
                raise TypeMismatchInExpression(ctx)
        elif ctx.op == ">" or ctx.op == "<" or ctx.op == "==" or ctx.op == "!=":
            if ctx.e1.accept(self, o) != ctx.e2.accept(self, o):
                raise TypeMismatchInExpression(ctx)
            else:
                return "bool"

    def visitUnOp(self,ctx:UnOp,o):
        if ctx.op == "-":
            if ctx.e.accept(self, o) == "bool":
                raise TypeMismatchInExpression(ctx)
            elif ctx.e.accept(self, o) == "int":
                return "int"
            elif ctx.e.accept(self, o) == "float":
                return "float"
        elif ctx.op == "!":
            if ctx.e.accept(self, o) == "bool":
                return "bool"
            raise TypeMismatchInExpression(ctx)


    def visitIntLit(self,ctx:IntLit,o):
        if isinstance(ctx.val, int):
            return "int"
        else:
            raise TypeMismatchInExpression(ctx)
            
    def visitFloatLit(self,ctx,o):
        if isinstance(ctx.val, float):
            return "float"
        else:
            raise TypeMismatchInExpression(ctx)

    def visitBoolLit(self,ctx,o):
        if isinstance(ctx.val, bool):
            return "bool"
        else:
            raise TypeMismatchInExpression(ctx)

    def visitId(self,ctx,o):
        for x in o:
            if ctx.name == x[0]:
                return x[1]
        raise UndeclaredIdentifier(ctx.name)

Program([],BinOp("+",IntLit(3),BoolLit(True)))
Type Mismatch In Expression: BinOp("+",IntLit(3),BoolLit(True))
Type Mismatch In Expression: BinOp("+",IntLit(3),BoolLit(True))
Chính xác
Chính xác	
Program([VarDecl("x",IntType())],BinOp("*",BinOp("+",Id("x"),FloatLit(3.4)),BinOp(">",IntLit(3),FloatLit(2.1))))
Type Mismatch In Expression: BinOp(">",IntLit(3),FloatLit(2.1))
Type Mismatch In Expression: BinOp(">",IntLit(3),FloatLit(2.1))
Chính xác
Chính xác	
Program([VarDecl("x",IntType()),VarDecl("y",BoolType())],BinOp("&&",BinOp(">",BinOp("-",IntLit(3),FloatLit(3.4)),UnOp("-",FloatLit(2.1))),UnOp("-",Id("y"))))
Type Mismatch In Expression: UnOp("-",Id("y"))
Type Mismatch In Expression: UnOp("-",Id("y"))
Chính xác
Chính xác	
Program([VarDecl("x",IntType())],UnOp("-",BinOp(">",BinOp("-",Id("x"),FloatLit(3.4)),UnOp("-",FloatLit(2.1)))))
Type Mismatch In Expression: UnOp("-",BinOp(">",BinOp("-",Id("x"),FloatLit(3.4)),UnOp("-",FloatLit(2.1))))
Type Mismatch In Expression: UnOp("-",BinOp(">",BinOp("-",Id("x"),FloatLit(3.4)),UnOp("-",FloatLit(2.1))))
Chính xác
Chính xác	
Program([VarDecl("x",BoolType()),VarDecl("y",BoolType()),VarDecl("z",FloatType())],BinOp(">",BinOp("&&",Id("x"),Id("y")),BinOp("||",BoolLit(True),UnOp("-",Id("z")))))
Type Mismatch In Expression: BinOp("||",BoolLit(True),UnOp("-",Id("z")))
Type Mismatch In Expression: BinOp("||",BoolLit(True),UnOp("-",Id("z")))
Chính xác
Chính xác	
Program([VarDecl("x",IntType()),VarDecl("y",IntType()),VarDecl("z",IntType())],UnOp("!",BinOp("==",Id("z"),BinOp("*",Id("y"),Id("x")))))
Chính xác
Chính xác	
Program([VarDecl("x",IntType()),VarDecl("y",IntType()),VarDecl("z",IntType())],UnOp("!",BinOp("==",Id("x"),BinOp("/",Id("y"),Id("z")))))
Type Mismatch In Expression: BinOp("==",Id("x"),BinOp("/",Id("y"),Id("z")))
Type Mismatch In Expression: BinOp("==",Id("x"),BinOp("/",Id("y"),Id("z")))
Chính xác
Chính xác	
Program([VarDecl("x",IntType()),VarDecl("y",IntType()),VarDecl("z",IntType())],UnOp("!",BinOp("-",Id("z"),BinOp("/",Id("y"),Id("x")))))
Type Mismatch In Expression: UnOp("!",BinOp("-",Id("z"),BinOp("/",Id("y"),Id("x"))))
Type Mismatch In Expression: UnOp("!",BinOp("-",Id("z"),BinOp("/",Id("y"),Id("x"))))
Chính xác
Chính xác	
Program([VarDecl("x",IntType()),VarDecl("y",IntType()),VarDecl("z",IntType())],BinOp("/",Id("x"),BinOp("<",Id("y"),Id("z"))))
Type Mismatch In Expression: BinOp("/",Id("x"),BinOp("<",Id("y"),Id("z")))
Type Mismatch In Expression: BinOp("/",Id("x"),BinOp("<",Id("y"),Id("z")))
Chính xác
Chính xác	
Program([VarDecl("x",IntType()),VarDecl("y",IntType()),VarDecl("z",IntType())],BinOp("||",BoolLit(True),BinOp("<",IntLit(3),Id("t"))))
Undeclared Identifier: t
Undeclared Identifier: t
Chính xác
Passed all tests!  Chính xác