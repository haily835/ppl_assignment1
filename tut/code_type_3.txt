Given the AST declarations as follows:

class Program: #decl:List[VarDecl],stmts:List[Assign]

class VarDecl: #name:str

class Assign: #lhs:Id,rhs:Exp

class Exp(ABC): #abstract class

class BinOp(Exp): #op:str,e1:Exp,e2:Exp #op is +,-,*,/,+.,-.,*.,/., &&,||, >, >., >b, =, =., =b

class UnOp(Exp): #op:str,e:Exp #op is -,-., !,i2f, floor

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

class Id(Exp): #name:str

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):pass

    def visitVarDecl(self,ctx:VarDecl,o): pass

    def visitAssign(self,ctx:Assign,o): pass

    def visitBinOp(self,ctx:BinOp,o): pass

    def visitUnOp(self,ctx:UnOp,o):pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

    def visitId(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to infer the type of identifiers and check the following type constraints:

+ , - , *, / accept their operands in int type and return int type
+., -., *., /. accept their operands in float type and return float type
> and = accept their operands in int type and return bool type
>. and =. accept their operands in float type and return bool type
!, &&, ||, >b and =b accept their operands in bool type and return bool type
i2f accepts its operand in int type and return float type
floor accept its operand in float type and return int type
In an assignment statement, the type of lhs must be the same as that of rhs, otherwise, the exception TypeMismatchInStatement should be raised together with the assignment statement.
the type of an Id is inferred from the above constraints in the first usage, 
if the Id is not in the declarations, exception UndeclaredIdentifier should be raised together with the name of the Id, or
If the Id cannot be inferred in the first usage, exception TypeCannotBeInferred should be raised together with the name of the assignment statement.
If an expression does not conform the type constraints, the StaticCheck will raise exception TypeMismatchInExpression with the expression.
Your code starts at line 95


class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):
        expect = ""
        o = {"ids": [], "expect": ""}
        for x in ctx.decl:
            o["ids"].append({"name": x.accept(self,None), "type": ""})
        for x in ctx.exp:
            x.accept(self, o)

    def visitVarDecl(self,ctx:VarDecl,o):
        return ctx.name
        
    def visitAssign(self,ctx:Assign,o):
        ctx.lhs.accept(self,o)
        o["expect"] = ctx.rhs.accept(self,o)
        if (ctx.lhs.accept(self, o) != ctx.rhs.accept(self,o)):
            raise TypeMismatchInStatement(ctx)
        if (ctx.rhs.accept(self,o) == ""):
            raise TypeCannotBeInferred(ctx)

    def visitBinOp(self,ctx:BinOp,o):
        if (ctx.op == "+" or ctx.op == "-" or ctx.op == "*" or ctx.op == "/"):
            o["expect"] = "int"
            if (ctx.e1.accept(self,o) != "int") or (ctx.e2.accept(self,o) != "int"):
                raise TypeMismatchInExpression(ctx)
            else:
                return "int"
        if ctx.op == "+." or ctx.op == "-." or ctx.op == "*." or ctx.op == "/.":
            o["expect"] = "float"
            if (ctx.e1.accept(self,o) == "float"):
                o["expect"] = "float"
                if ctx.e2.accept(self,o) == "float":
                    return "float"
        if ctx.op == "&&" or ctx.op == "||" or ctx.op == ">b" or ctx.op == "=b":
            o["expect"] = "bool"
            if (ctx.e1.accept(self,o) == "bool" and ctx.e2.accept(self,o) == "bool"):
                return "bool"
        if ctx.op == ">" or ctx.op == "=":
            o["expect"] = "int"
            if (ctx.e1.accept(self,o) == "int" and ctx.e2.accept(self,o) == "int"):
                return "bool"
        if ctx.op == ">." or ctx.op == "=.":
            o["expect"] = "float"
            if (ctx.e1.accept(self,o) == "float" and ctx.e2.accept(self,o) == "float"):
                return "bool"
        raise TypeMismatchInExpression(ctx)

    def visitUnOp(self,ctx:UnOp,o):
        if ctx.op == "-":
            o["expect"] = "int"
            if (ctx.e.accept(self, o) == "int"):
                return "int"
            else: 
                raise TypeMismatchInExpression(ctx)
        elif ctx.op == "-.":
            o["expect"] = "float"
            if ctx.e.accept(self, o) == "float":
                return "float"
            else: 
                raise TypeMismatchInExpression(ctx)
        elif ctx.op == "i2f":
            o["expect"] = "int"
            if ctx.e.accept(self,o) == "int":
                return "float"
            else: 
                raise TypeMismatchInExpression(ctx)
        elif ctx.op == "floor":
            o["expect"] = "float"
            if ctx.e.accept(self,o) == "float":
                return "int"
            else: 
                raise TypeMismatchInExpression(ctx)
        elif ctx.op == "!":
            o["expect"] = "bool"
            if ctx.e.accept(self,o) == "bool":
                return "bool"
            else: 
                raise TypeMismatchInExpression(ctx)

    def visitIntLit(self,ctx:IntLit,o):
        return "int"

    def visitFloatLit(self,ctx,o):
        return "float"
        
    def visitBoolLit(self,ctx,o):
        return "bool"

    def visitId(self,ctx,o):
        found = 0
        for ele in o["ids"]:
            if ctx.name == ele["name"]:
                # print("visit: " + ctx.name)
                # print("current type: " + ele["type"])
                # print("expect: " + o["expect"])
                found = 1
                if (ele["type"] == "" and o["expect"]):
                    ele["type"] = o["expect"]
                # print("assigned: " + ele["type"])
                # print("----------")
                return ele["type"]
        if (found == 0):
            raise UndeclaredIdentifier(ctx.name)


Program([VarDecl("x")],[Assign(Id("x"),BinOp("+",IntLit(3),BoolLit(True)))])
Type Mismatch In Expression: BinOp("+",IntLit(3),BoolLit(True))
Type Mismatch In Expression: BinOp("+",IntLit(3),BoolLit(True))
Chính xác
Chính xác	
Program([VarDecl("x")],[Assign(Id("x"),BinOp("*",BinOp("+",Id("x"),IntLit(3.4)),BinOp("-",Id("x"),FloatLit(2.1))))])
Type Mismatch In Expression: BinOp("-",Id("x"),FloatLit(2.1))
Type Mismatch In Expression: BinOp("-",Id("x"),FloatLit(2.1))
Chính xác
Chính xác	
Program([VarDecl("x"),VarDecl("y"),VarDecl("z")],[Assign(Id("z"),BinOp("&&",BinOp(">",BinOp("-",Id("x"),IntLit(3)),UnOp("-",Id("y"))),UnOp("!",Id("y"))))])
Type Mismatch In Expression: UnOp("!",Id("y"))
Type Mismatch In Expression: UnOp("!",Id("y"))
Chính xác
Chính xác	
Program([VarDecl("x")],[Assign(Id("x"),UnOp("-",BinOp(">.",BinOp("-.",Id("x"),FloatLit(3.4)),UnOp("-.",FloatLit(2.1)))))])
Type Mismatch In Expression: UnOp("-",BinOp(">.",BinOp("-.",Id("x"),FloatLit(3.4)),UnOp("-.",FloatLit(2.1))))
Type Mismatch In Expression: UnOp("-",BinOp(">.",BinOp("-.",Id("x"),FloatLit(3.4)),UnOp("-.",FloatLit(2.1))))
Chính xác
Chính xác	
Program([VarDecl("x"),VarDecl("y"),VarDecl("z")],[Assign(Id("x"),BinOp(">b",BinOp("&&",Id("x"),Id("y")),BinOp("||",BoolLit(False),BinOp(">",Id("z"),IntLit(3))))),Assign(Id("z"),Id("x"))])
Type Mismatch In Statement: Assign(Id("z"),Id("x"))
Type Mismatch In Statement: Assign(Id("z"),Id("x"))
Chính xác
Chính xác	
Program([VarDecl("x"),VarDecl("y"),VarDecl("z")],[Assign(Id("x"),UnOp("!",BinOp("=",Id("z"),BinOp("*",Id("y"),Id("x")))))])
Type Mismatch In Statement: Assign(Id("x"),UnOp("!",BinOp("=",Id("z"),BinOp("*",Id("y"),Id("x")))))
Type Mismatch In Statement: Assign(Id("x"),UnOp("!",BinOp("=",Id("z"),BinOp("*",Id("y"),Id("x")))))
Chính xác
Chính xác	
Program([VarDecl("x"),VarDecl("y")],[Assign(Id("x"),Id("y"))])
Type Cannot Be Inferred: Assign(Id("x"),Id("y"))
Type Cannot Be Inferred: Assign(Id("x"),Id("y"))
Chính xác
Chính xác	
Program([VarDecl("x"),VarDecl("y"),VarDecl("z")],[Assign(Id("x"),UnOp("-.",BinOp("-.",Id("z"),BinOp("/.",UnOp("i2f",Id("y")),Id("x"))))),Assign(Id("y"),FloatLit(3.2))])
Type Mismatch In Statement: Assign(Id("y"),FloatLit(3.2))
Type Mismatch In Statement: Assign(Id("y"),FloatLit(3.2))
Chính xác
Chính xác	
Program([VarDecl("x"),VarDecl("y"),VarDecl("z")],[Assign(Id("z"),IntLit(3)),Assign(Id("x"),Id("z")),Assign(Id("y"),BinOp("&&",Id("x"),BinOp("=b",Id("y"),BoolLit(True))))])
Type Mismatch In Expression: BinOp("&&",Id("x"),BinOp("=b",Id("y"),BoolLit(True)))
Type Mismatch In Expression: BinOp("&&",Id("x"),BinOp("=b",Id("y"),BoolLit(True)))
Chính xác
Chính xác	
Program([VarDecl("x"),VarDecl("y"),VarDecl("z")],[Assign(Id("t"),BinOp("||",BoolLit(True),BinOp("<",IntLit(3),Id("z"))))])
Undeclared Identifier: t
Undeclared Identifier: t
Chính xác