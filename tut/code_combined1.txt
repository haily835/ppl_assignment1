Given the AST declarations as follows:

class Program: #decl:List[Decl],stmts:List[Stmt]

class Decl(ABC): #abstract class

class VarDecl(Decl): #name:str

class FuncDecl(Decl): #name:str,param:List[VarDecl],local:List[Decl],stmts:List[Stmt]

class Stmt(ABC): #abstract class

class Assign(Stmt): #lhs:Id,rhs:Exp

class CallStmt(Stmt): #name:str,args:List[Exp]

class Exp(ABC): #abstract class

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

class Id(Exp): #name:str

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):pass

    def visitVarDecl(self,ctx:VarDecl,o): pass

    def visitFuncDecl(self,ctx:FuncDecl,o): pass

    def visitCallStmt(self,ctx:CallStmt,o):pass

    def visitAssign(self,ctx:Assign,o): pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

    def visitId(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to infer the type of identifiers and check the following type constraints:

In an Assign, the type of lhs must be the same as that of rhs, otherwise, the exception TypeMismatchInStatement should be raised together with the Assign
the type of an Id is inferred from the above constraints in the first usage, 
if the Id is not in the declarations, exception UndeclaredIdentifier should be raised together with the name of the Id, or
If the Id cannot be inferred in the first usage, exception TypeCannotBeInferred should be raised together with the statement
For static referencing environment, this language applies the scope rules of block-structured programming language where a function is a block. When there is a declaration duplication of a name in a scope, exception Redeclared should be raised together with the second declaration.
In a call statement, the argument type must be the same as the parameter type. If there is no function declaration in the static referencing environment, exception UndeclaredIdentifier should be raised together with the function call name. If the numbers of parameters and arguments are not the same or at least one argument type is not the same as the type of the corresponding parameter, exception TypeMismatchInStatement should be raise with the call statement. If there is at least one parameter type cannot be resolved, exception TypeCannotBeInferred should be raised together with the call statement.
Your code starts at line 120



[from functools import reduce
class StaticCheck(Visitor):
    def infer(self,o, name, expect):
        for scope in o:
            done = 0
            for x in scope:
                if name == x[0]:
                    x[2] = expect
                    done = 1 
                    break
            if done:
                break
                
    def visitProgram(self,ctx:Program,o):
        o = reduce(lambda acc,ele: acc + [ele.accept(self,[acc])], ctx.decl,[])
        # print(o)
        for x in ctx.stmts:
            x.accept(self, [o])
        
    def visitVarDecl(self,ctx:VarDecl,o):
        for x in o[0]:
            if ctx.name == x[0]:
                raise Redeclared(ctx)
        return [ctx.name, '', '']

    def visitFuncDecl(self,ctx:FuncDecl,o):
        # print(o)
        # check if the id is already used
        for x in o[0]:
            if ctx.name == x[0]:
                raise Redeclared(ctx)
        
        # get the list of parameter
        param_name = [x.name for x in ctx.param]
        
        # visit local each declaration is in the form [name, type, expect]
        local = reduce(lambda acc,ele: acc + [ele.accept(self, [acc] + o)], ctx.param + ctx.local,[[ctx.name, [], []]])
        
        # the environment to check statements after local declarations
        env = [local] + o
        
        # this array holds the expect in put of the this function:
        # ie. foo(a, b, c) => ['foo', [[x, 'type of x'], [y, 'type of y']], '']
        # func_expect = [[x, 'type of x'], [y, 'type of y']]
        func_expect = []
        
        # visit the statements list, during this the parameter type may be infered.
        for x in ctx.stmts:
            x.accept(self,env)

        for x in local:
            # add to func_expect the parameter and type of it
            if x[0] in param_name:
                func_expect.append([x[0],x[1]])
                
        return [ctx.name, func_expect, '']

    def visitAssign(self,ctx:Assign,o):
        typeRight = ctx.rhs.accept(self,o)
        typeLeft = ctx.lhs.accept(self,o)
        # print(typeLeft)
        # print(typeRight)
        if(typeLeft == "" and typeRight):
            self.infer(o, ctx.lhs.name, typeRight)
            typeLeft = ctx.lhs.accept(self,o)
        if(typeRight == "" and typeLeft):
            self.infer(o, ctx.rhs.name, typeLeft)
            typeRight = ctx.rhs.accept(self,o)
        if(typeRight != "" and typeLeft != "" and typeLeft != typeRight ):
            raise TypeMismatchInStatement(ctx)
        if(typeRight == "" and typeLeft == "" ):
            raise TypeCannotBeInferred(ctx)
    
    # name:str,args:List[Exp]
    def visitCallStmt(self,ctx:CallStmt,o):
        expect = []
        found = 0 # find the function
        
        # try to infer the function expect inputs by the args type if expect input is not known
        expect_back = [x.accept(self,o) for x in ctx.args]
        for scope in o:
            done = 0
            for x in scope:
                if ctx.name == x[0]:
                    if isinstance(x[1], list):
                        if len(x[1]) == len(expect_back):
                            for i in range(0, len(x[1])):
                                if x[1][i][1] == "" and expect_back[i] != "":
                                    x[1][i][1] = expect_back[i]
                        # print("After trying to match:")
                        # print(x)
                        expect = [k[1] for k in x[1]]
                        done = 1
                        found = 1
                        break
            if done:
                break
        if found == 0:
            raise UndeclaredIdentifier(ctx.name)
        if len(expect) == len(ctx.args):
            # try to infer type
            res = []
            for i in range(0, len(expect)):
                if ctx.args[i].accept(self,o) == "":
                    for scope in o:
                        done = False
                        for x in scope:
                            if ctx.args[i].name == x[0]:
                                x[2] = expect[i]
                                done = True
                                break
                        if done:
                            break
                res.append(ctx.args[i].accept(self,o))
            # print(res)
            if ( "" in res ):
                raise TypeCannotBeInferred(ctx)
            if (res != expect):
                raise TypeMismatchInStatement(ctx)
        else:
            raise TypeMismatchInStatement(ctx)

    def visitBinOp(self,ctx:BinOp,o):
        if (ctx.op == "+" or ctx.op == "-" or ctx.op == "*" or ctx.op == "/"):
            # if either or both operands types is unclear
            if (ctx.e1.accept(self,o) == ""):
                self.infer(o, ctx.e1.name, "int")
            if (ctx.e2.accept(self,o) == ""):
                self.infer(o, ctx.e2.name, "int")
            if (ctx.e1.accept(self,o) == "int" and ctx.e2.accept(self,o) == "int"):
                return "int"
        if ctx.op == "+." or ctx.op == "-." or ctx.op == "*." or ctx.op == "/.":
            if (ctx.e1.accept(self,o) == ""):
                self.infer(o, ctx.e1.name, "float")
            if (ctx.e2.accept(self,o) == ""):
                self.infer(o, ctx.e2.name, "float")
            if (ctx.e1.accept(self,o) == "float" and ctx.e2.accept(self,o) == "float"):
                return "float"
        if ctx.op == "&&" or ctx.op == "||" or ctx.op == ">b" or ctx.op == "=b":
            if (ctx.e1.accept(self,o) == ""):
                self.infer(o, ctx.e1.name, "bool")
            if (ctx.e2.accept(self,o) == ""):
                self.infer(o, ctx.e2.name, "bool")
            if (ctx.e1.accept(self,o) == "bool" and ctx.e2.accept(self,o) == "bool"):
                return "bool"
        if ctx.op == ">" or ctx.op == "=":
            if (ctx.e1.accept(self,o) == ""):
                self.infer(o, ctx.e1.name, "int")
            if (ctx.e2.accept(self,o) == ""):
                self.infer(o, ctx.e2.name, "int")
            if (ctx.e1.accept(self,o) == "int" and ctx.e2.accept(self,o) == "int"):
                return "int"
        if ctx.op == ">." or ctx.op == "=.":
            if (ctx.e1.accept(self,o) == ""):
                self.infer(o, ctx.e1.name, "float")
            if (ctx.e2.accept(self,o) == ""):
                self.infer(o, ctx.e2.name, "float")
            if (ctx.e1.accept(self,o) == "float" and ctx.e2.accept(self,o) == "float"):
                return "float"
        raise TypeMismatchInExpression(ctx)

    def visitUnOp(self,ctx:UnOp,o):
        operandType = ctx.e.accept(self,o)
        
        if ctx.op == "-":
            if (operandType == ""):
                self.infer(o, ctx.e.name, "int")
            if (ctx.e.accept(self,o) == "int"):
                return "int"
                
        if ctx.op == "-.":
            if (operandType == ""):
                self.infer(o, ctx.e.name, "float")
            if (ctx.e.accept(self,o) == "float"):
                return "float"
                
        if ctx.op == "i2f":
            if (operandType == ""):
                self.infer(o, ctx.e.name, "int")
            if (ctx.e.accept(self,o) == "int"):
                return "float"
                
        if ctx.op == "floor":
            if (operandType == ""):
                self.infer(o, ctx.e.name, "float")
            if (ctx.e.accept(self,o) == "float"):
                return "int"
                
        if ctx.op == "!":
            if (operandType == ""):
                self.infer(o, ctx.e.name, "bool")
            if (ctx.e.accept(self,o) == "bool"):
                return "bool"
        
        raise TypeMismatchInExpression(ctx)

    def visitIntLit(self,ctx:IntLit,o):
        return "int"

    def visitFloatLit(self,ctx,o):
        return "float"

    def visitBoolLit(self,ctx,o):
        return "bool"

    def visitId(self,ctx,o):
        unfound = 1
        # print(o)
        for scope in o:
            for x in scope:
                if ctx.name == x[0]:
                    unfound = 0
                    if (x[1] == "" and x[2]):
                        x[1] = x[2]
                    return x[1]
        if unfound:
            raise UndeclaredIdentifier(ctx.name)]


Test	Expected	Got	
Chính xác	
Program([VarDecl("x"),FuncDecl("foo",[VarDecl("x")],[],[Assign(Id("x"),FloatLit(2))])],[Assign(Id("x"),IntLit(3)),CallStmt("foo",[Id("x")])])
Type Mismatch In Statement: CallStmt("foo",[Id("x")])
Type Mismatch In Statement: CallStmt("foo",[Id("x")])
Chính xác
Chính xác	
Program([VarDecl("x"),FuncDecl("foo",[],[VarDecl("x")],[Assign(Id("x"),FloatLit(2))])],[Assign(Id("x"),IntLit(3)),CallStmt("foo",[Id("x")])])
Type Mismatch In Statement: CallStmt("foo",[Id("x")])
Type Mismatch In Statement: CallStmt("foo",[Id("x")])
Chính xác
Chính xác	
Program([VarDecl("x"),FuncDecl("x",[VarDecl("y")],[],[])],[])
Redeclared: FuncDecl(x,[VarDecl("y")],[],[])
Redeclared: FuncDecl(x,[VarDecl("y")],[],[])
Chính xác
Chính xác	
Program([VarDecl("x"),FuncDecl("foo",[VarDecl("y")],[],[CallStmt("x",[])])],[])
Undeclared Identifier: x
Undeclared Identifier: x
Chính xác
Chính xác	
Program([VarDecl("x"),FuncDecl("foo",[VarDecl("y")],[FuncDecl("foo2",[],[],[])],[CallStmt("foo2",[])])],[CallStmt("foo2",[])])
Undeclared Identifier: foo2
Undeclared Identifier: foo2
Chính xác
Chính xác	
Program([VarDecl("x"),FuncDecl("foo",[VarDecl("y")],[],[])],[CallStmt("foo",[IntLit(3)]),CallStmt("foo",[Id("x")]),Assign(Id("x"),FloatLit(0.0))])
Type Mismatch In Statement: Assign(Id("x"),FloatLit(0.0))
Type Mismatch In Statement: Assign(Id("x"),FloatLit(0.0))
Chính xác
Chính xác	
Program([VarDecl("x"),FuncDecl("foo",[VarDecl("y"),VarDecl("z")],[],[Assign(Id("z"),FloatLit(0.0))])],[CallStmt("foo",[IntLit(3),Id("x")]),CallStmt("foo",[Id("x"),FloatLit(0.0)])])
Type Mismatch In Statement: CallStmt("foo",[Id("x"),FloatLit(0.0)])
Type Mismatch In Statement: CallStmt("foo",[Id("x"),FloatLit(0.0)])
Chính xác
Chính xác	
Program([VarDecl("x"),FuncDecl("foo",[VarDecl("y"),VarDecl("z")],[],[])],[CallStmt("foo",[IntLit(3),Id("x")])])
Type Cannot Be Inferred: CallStmt("foo",[IntLit(3),Id("x")])
Type Cannot Be Inferred: CallStmt("foo",[IntLit(3),Id("x")])